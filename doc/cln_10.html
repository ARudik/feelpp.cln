<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from cln.texi on 4 May 2000 -->

<TITLE>CLN, a Class Library for Numbers - 10. Internals</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cln_1.html">first</A>, <A HREF="cln_9.html">previous</A>, <A HREF="cln_11.html">next</A>, <A HREF="cln_13.html">last</A> section, <A HREF="cln_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC58" HREF="cln_toc.html#TOC58">10. Internals</A></H1>



<H2><A NAME="SEC59" HREF="cln_toc.html#TOC59">10.1 Why C++ ?</A></H2>
<P>
<A NAME="IDX303"></A>


<P>
Using C++ as an implementation language provides



<UL>
<LI>

Efficiency: It compiles to machine code.

<LI>

<A NAME="IDX304"></A>
Portability: It runs on all platforms supporting a C++ compiler. Because
of the availability of GNU C++, this includes all currently used 32-bit and
64-bit platforms, independently of the quality of the vendor's C++ compiler.

<LI>

Type safety: The C++ compilers knows about the number types and complains if,
for example, you try to assign a float to an integer variable. However,
a drawback is that C++ doesn't know about generic types, hence a restriction
like that <CODE>operator+ (const cl_MI&#38;, const cl_MI&#38;)</CODE> requires that both
arguments belong to the same modular ring cannot be expressed as a compile-time
information.

<LI>

Algebraic syntax: The elementary operations <CODE>+</CODE>, <CODE>-</CODE>, <CODE>*</CODE>,
<CODE>=</CODE>, <CODE>==</CODE>, ... can be used in infix notation, which is more
convenient than Lisp notation <SAMP>`(+ x y)'</SAMP> or C notation <SAMP>`add(x,y,&#38;z)'</SAMP>.
</UL>

<P>
With these language features, there is no need for two separate languages,
one for the implementation of the library and one in which the library's users
can program. This means that a prototype implementation of an algorithm
can be integrated into the library immediately after it has been tested and
debugged. No need to rewrite it in a low-level language after having prototyped
in a high-level language.




<H2><A NAME="SEC60" HREF="cln_toc.html#TOC60">10.2 Memory efficiency</A></H2>

<P>
In order to save memory allocations, CLN implements:



<UL>
<LI>

Object sharing: An operation like <CODE>x+0</CODE> returns <CODE>x</CODE> without copying
it.
<LI>

<A NAME="IDX305"></A>
<A NAME="IDX306"></A>
Garbage collection: A reference counting mechanism makes sure that any
number object's storage is freed immediately when the last reference to the
object is gone.
<LI>

Small integers are represented as immediate values instead of pointers
to heap allocated storage. This means that integers <CODE>&#62; -2^29</CODE>,
<CODE>&#60; 2^29</CODE> don't consume heap memory, unless they were explicitly allocated
on the heap.
</UL>



<H2><A NAME="SEC61" HREF="cln_toc.html#TOC61">10.3 Speed efficiency</A></H2>

<P>
Speed efficiency is obtained by the combination of the following tricks
and algorithms:



<UL>
<LI>

Small integers, being represented as immediate values, don't require
memory access, just a couple of instructions for each elementary operation.
<LI>

The kernel of CLN has been written in assembly language for some CPUs
(<CODE>i386</CODE>, <CODE>m68k</CODE>, <CODE>sparc</CODE>, <CODE>mips</CODE>, <CODE>arm</CODE>).
<LI>

On all CPUs, CLN may be configured to use the superefficient low-level
routines from GNU GMP version 3.
<LI>

For large numbers, CLN uses, instead of the standard <CODE>O(N^2)</CODE>
algorithm, the Karatsuba multiplication, which is an
<CODE>O(N^1.6)</CODE>
algorithm.
<LI>

For very large numbers (more than 12000 decimal digits), CLN uses
Schönhage-Strassen
<A NAME="IDX307"></A>
multiplication, which is an asymptotically
optimal multiplication algorithm.
<LI>

These fast multiplication algorithms also give improvements in the speed
of division and radix conversion.
</UL>



<H2><A NAME="SEC62" HREF="cln_toc.html#TOC62">10.4 Garbage collection</A></H2>
<P>
<A NAME="IDX308"></A>


<P>
All the number classes are reference count classes: They only contain a pointer
to an object in the heap. Upon construction, assignment and destruction of
number objects, only the objects' reference count are manipulated.


<P>
Memory occupied by number objects are automatically reclaimed as soon as
their reference count drops to zero.


<P>
For number rings, another strategy is implemented: There is a cache of,
for example, the modular integer rings. A modular integer ring is destroyed
only if its reference count dropped to zero and the cache is about to be
resized. The effect of this strategy is that recently used rings remain
cached, whereas undue memory consumption through cached rings is avoided.


<P><HR><P>
Go to the <A HREF="cln_1.html">first</A>, <A HREF="cln_9.html">previous</A>, <A HREF="cln_11.html">next</A>, <A HREF="cln_13.html">last</A> section, <A HREF="cln_toc.html">table of contents</A>.
</BODY>
</HTML>
